fn main() {
    let x = String::from("gray");
    let y = "cassible".to_string();
    let result = longest(&x, &y);
    println!("result is {result}");
}

/*
一个变量在创建时生命周期随之开始，销毁时生命周期也随之结束。
在存在多个引用时，编译器有时会无法自动推导生命周期。无法得知返回的是哪个引用
和泛型一样，使用生命周期参数，需要先声明 <'a>
x、y 和返回值至少活得和 'a 一样久(因为返回值要么是 x，要么是 y)
我的理解： 我用的东西至少要和我活的一样久(or 更久),不然我怕我用到一半他没了怎么办？
放到代码里就是： 我处于东西的中间，没问题☑️
创建我用到的东西； --- 东西进入
创建我；         --- 我进入
我使用东西；      --- 东西结束 + 我结束
-----------------------------------
东西存活的时间比我更短，编译器觉得会有风险（用到一半东西没了），拒绝编译。如何解决？ 通过生命周期 告诉编译器东西其实是活的和我一样久的，编译器知道了就会去编译了。把生命周期理解为通过注释告诉编译器的一些规则，并不会实际改变任何代码运行结果。
创建我；              --- 我进入
创建我用到的东西；      --- 东西进入
我使用东西；           --- 东西结束 + 我结束

函数的返回值如果是一个引用类型，那么它的生命周期只会来源于：
函数参数的生命周期
函数体中某个新建引用的生命周期 若是这个情况，就是典型的悬垂引用场景。因为函数体中的变量在函数结束后就销毁了。
这也解释了为什么有时候又不需要我们显式标注生命周期，因为在这两种情况中，第二种是必定不编译的，那么编译器就只需要检查第一种情况，在只有一个引用参数的情况下，编译器自然能看出来。
函数或者方法中，参数的生命周期被称为 输入生命周期，返回值的生命周期被称为 输出生命周期。
Rust默认的生命周期消除规则：
1.每个引用参数都会获得独立的生命周期。
2.若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期
3.若存在多个输入生命周期，且其中一个是 &self 或 &mut self，则 &self 的生命周期被赋给所有的输出生命周期，拥有 &self 形式的参数，说明该函数是一个 方法，该规则让方法的使用便利度大幅提升。
生命周期约束  'a:'b --- 表示'a的生命周期大于等于'b

静态生命周期 ：'static，拥有该生命周期的引用可以和整个程序活得一样久。
生命周期 'static 意味着能和程序活得一样久，例如字符串字面量和特征对象
实在遇到解决不了的生命周期标注问题，可以尝试 T: 'static，有时候它会给你奇迹
 */
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if (x.len() > y.len()) {
        x
    } else {
        y
    }
}
