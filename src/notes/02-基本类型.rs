fn main() {
    about_number();
    about_char_bool();
    about_statement_expression();
    about_func_return();
}

/**
* 分为整数类型和浮点数类型(f32 f64) 默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。
* 其中整数类型分为有符号整数(i)，无符号整数(u)
* 每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1
* 无符号类型可以存储的数字范围是 0 ~ 2n - 1
* i8 --> -128 至 127  u8 --> 0 至 255
* i16 --> -32,768 至 32,767 u16 --> 0 至 65535
* i32 --> -2,147,483,648 至 2,147,483,647 u32 -->  0 至 4,294,967,295 Rust默认数值类型为i32
* i64 -->  -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 u64 --> 0 至 18,446,744,073,709,551,615
* isize / usize --> 视架构而定：取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。isize 和 usize 的主要应用场景是用作集合的索引。
* 关于整形溢出问题：
假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。
要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
如果使用 checked_* 方法时发生溢出，则返回 None 值
使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
使用 saturating_* 方法使值达到最小值或最大值
NaN的定义和使用与js一致
Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中
*/
fn about_number() {
    let a: u8 = 255;
    let b = a.wrapping_add(20);
    println!("b {}", b); // 19
    let c = a.checked_add(20);
    println!("c {:?}", c); // None
    let d = a.overflowing_add(20);
    println!("d {:?}", d); // (19,true) 代表溢出了19
    let e = a.saturating_add(20);
    println!("e {}", e); // 达到最大值255
    assert!((0.1_f64 + 0.2 - 0.3).abs() < 0.001); // 在Rust 中使用abs()函数获取绝对值 要获得绝对值,我们需要明确指定数据类型。
                                                  // 对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 == 0.3 通过测试
                                                  //  但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾

    assert!(0.1_f32 + 0.2_f32 == 0.3_f32);
    for c in 'a'..='z' {
        println!("{}", c as u8); // 输出: 97 - 122  as强制转换类型
    }
}

/**
 * 所有的 Unicode 值都可以作为 Rust 字符，
 * 在 Rust 中，字符串是使用 UTF-8 编码表示的，因此字符串中每个字符的大小可以是 1-4 个字节。
 * 而 char 类型表示的是单个 Unicode 字符，它的大小是 4 个字节（即 UTF-32 编码格式）。
 * 需要注意 字符用''  “”是留给字符串的。
 */
use std::mem::size_of_val;
fn about_char_bool() {
    let x = 'a';
    let y = '啊';
    let z = '🤔';
    assert_eq!(size_of_val(&x), 4);
    assert_eq!(size_of_val(&y), 4);
    assert_eq!(size_of_val(&z), 4);
}
// 布尔值占用内存的大小为 1 个字节
// 单元类型就是 () ，对，你没看错，就是 () ，唯一的值也是 ()
// main 函数就返回这个单元类型 ()，你不能说 main 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：发散函数( diverge function )，顾名思义，无法收敛的函数。
// 例如常见的 println!() 的返回值也是单元类型 ()。
// 再比如，你可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。
// 这种用法和 Go 语言的 struct{} 类似，可以作为一个值用来占位，但是完全不占用任何内存。

/**
 * 语句结尾有;
 * 表达式结尾不能有分号
 *
 */
fn about_statement_expression() {
    let y = {
        let x = 4;
        x + 1
    };
    println!("y is {}", y); // 5
    let x = 3;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let z = if x % 2 == 1 { "odd" } else { "even" };
    println!("z is {}", z); // odd
    let v = {
        let mut x = 1;
        x += 2
    };
    // assert_eq!(v, 3); // error 赋值表达式的返回值是() x+=2可以理解为x = x + 2 x+2的返回值绑定到了x，而这个赋值表达式的返回值是()
    assert_eq!(v, ());
}

/**
* 两种返回方式：第一种无分号返回的表达式，第二种显式的return
* 当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：
* eg1: fn dead_end() -> ! {
 panic!("你已经到了穷途末路，崩溃吧！");
      }
eg2 :下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回
fn forever() -> ! {
  loop {
    //...
  };
}
*/
fn about_func_return() -> char {
    let x = 5;
    if x > 3 {
        return '5';
    };
    '0'
}
