fn main() {
    about_number()
}

/**
* 分为整数类型和浮点数类型(f32 f64) 默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。
* 其中整数类型分为有符号整数(i)，无符号整数(u)
* 每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1
* 无符号类型可以存储的数字范围是 0 ~ 2n - 1
* i8 --> -128 至 127  u8 --> 0 至 255
* i16 --> -32,768 至 32,767 u16 --> 0 至 65535
* i32 --> -2,147,483,648 至 2,147,483,647 u32 -->  0 至 4,294,967,295 Rust默认数值类型为i32
* i64 -->  -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 u64 --> 0 至 18,446,744,073,709,551,615
* isize / usize --> 视架构而定：取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。isize 和 usize 的主要应用场景是用作集合的索引。
* 关于整形溢出问题：
假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。
要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
如果使用 checked_* 方法时发生溢出，则返回 None 值
使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
使用 saturating_* 方法使值达到最小值或最大值
*/
fn about_number() {
    let a: u8 = 255;
    let b = a.wrapping_add(20);
    println!("b {}", b); // 19
    let c = a.checked_add(20);
    println!("c {:?}", c); // None
    let d = a.overflowing_add(20);
    println!("d {:?}", d); // (19,true) 代表溢出了19
    let e = a.saturating_add(20);
    println!("e {}", e); // 达到最大值255
}
